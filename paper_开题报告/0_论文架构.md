### 格式

- 如图 3-1(a)所示
- 如表 3-1 所示





### 参考文献



| 相关文献 | 计算资源 | 优化目标                                               | 卸载类型 |      |      | 决策方式 |
| -------- | -------- | ------------------------------------------------------ | -------- | ---- | ---- | -------- |
| 13       | VC.RC    | 最小化卸载延迟和能量消耗                               | 全部卸载 | 独立 | 移动 | 集中决策 |
| C327     | VC,EC,RC | 最小化卸载延迟和能量消耗                               | 全部卸载 | 独立 | 移动 | 集中决策 |
| 337      | Ve       | 最小化移动设备卸载延迟和能量消耗（车辆形成VC提供服务） | 部分卸载 | 依赖 | 移动 | 自主决策 |
| 34】     | VC.RC    | 优化车辆计算和能源利用的同时将任务延退最小化           |          | 独立 | 停泊 | 自主决策 |
| 35       | EC       | 最小化车辆任务延迟和租用MEC价格                        | 部分卸载 | 独立 | 移动 | 自主决策 |
| 367      | VC       | 最小化请求车辆卸载成本                                 |          | 独立 | 停泊 | 自主决策 |
| 37-38】  | VC       | 最小化卸载延迟                                         | 全部卸载 | 独立 | 移动 | 自主决策 |
| 39J      | VC       | 最小化卸载延退并提高服务的可靠性                       | 全部卸载 | 独立 | 移动 | 自主决策 |
| 【40】   | VC       | 保证任务处理的时效性                                   | 全部卸载 | 独立 | 移动 | 集中决策 |
| 【41】   | VC,EC    | 最小化卸载延迟                                         | 部分卸载 | 依赖 | 移动 | 自主决策 |
| 【42】   | EC       | 考虑能耗和延迟的同时提高用户体验质量                   | 全部卸载 | 独立 | 移动 | 集中决策 |
| 【43】   | VC.EC    | 满足任务延迟约束的同时降低整体能耗                     | 全部卸载 | 独立 |      | 集中决策 |
| 44】     | VC.EC    | 最大化VEC网络的长期效用                                | 部分卸载 | 独立 | 移动 | 集中决策 |
| 45       | VC,EC.RC | 降低处理时延和系统能量消耗                             |          | 独立 | 移动 | 集中决策 |
| 【46】   | VC       | 最小化卸载延迟                                         | 部分卸载 | 独立 | 移动 | 自主决策 |
| 47】     | VC       | 卸载延迟和服务质量                                     | 全部卸载 | 独立 | 移动 | 集中决策 |
| 【48】   | VC       | 最小化系统所有车辆卸载延退                             | 部分卸载 | 独立 | 移动 | 集中决策 |
| L49】    | VC       | 最小化卸载延迟                                         |          | 依赖 | 移动 | 集中决策 |
| C507     | VC.EC    | 最小化系统卸载延迟                                     | 部分卸载 | 独立 | 移动 | 集中决策 |
| 51-527   | EC       | 最大化服务提供商收益，同时提高车辆的效用               | 部分卸载 | 独立 | 移动 | 集中决策 |
| 89       | VC,EC    | 最大化服务提供商效益，并提高停靠车辆效益               | 全部卸载 | 独立 | 停泊 | 集中决策 |
| L547     | EC       | 最小化卸载延迟同时EC服务器负载均衡                     | 部分卸载 | 独立 | 移动 | 自主决策 |
| 55       | EC       | 同时优化车辆和MEC服务器的成本                          | 部分卸载 | 独立 | 移动 | 集中决策 |
| 56       | VC.EC    | 最小化任务超时概率                                     | 全部卸载 | 独立 | 移动 | 集中决策 |





### 基于移动边缘计算的车辆任务卸载算法研究-------卞浩卜

第一章绪论

- 1.1研究背景及意义一
- 1.2国内外研究现状…
- 1.3研究内容与论文结构安排、

第二章边缘计算及车联网任务卸载相关技-

- 2.1边缘计算>
- ·2.2车联网任务卸载~·

第三章基于模拟退火算法的车辆任务卸载

- 3.1引言)
- 3.2系统模型
- 3.3问题建模)·
- 3.4基于模拟退火算法的任务调度和资
- 3.5仿真及性能分析-
- 3.6本章小结v.

第四章基于D2D辅助的RSU缓存和车载计

- 4.1引言>·
- 4.2系统模型
- 4.3问题建立
- 4.4收益最大化的缓存算法)·
- 4.5卸载算法
- 4.6仿真及性能分析
- 47本章小结v.

第五章基于MEC和基站结合的业务管控系

- 5.1MEC部署方案5.2基于MEC的智能内容分发5.3局域网管控系统设计5.4公网管控系统设计5.5系统实现-5.6系统测试5.7本章小结第六章总结与展望6.1总结6.2展望参考文献



### prompt\_论文润色

> 充当论文润色者（拿摘要部分举例）
>
> > 请你充当一名论文编辑专家，在论文评审的角度去修改以下论文，使其更加流畅，优美。下面是具体要求：
>
> 1. 能让读者快速获得文章的要点或精髓，让文章引人入胜；能让读者了解全文中的重要信息、分析和论点；帮助读者记住论文的要点
> 2. 字数限制在 300 字以下
> 3. 请你在摘要中明确指出您的模型和方法的创新点，强调您的贡献。
> 4. 用简洁、明了的语言描述您的方法和结果，以便评审更容易理解论文
>
> > 下文是论文的摘要部分，请你修改它：





#### 论文降重

> 你是一个期刊收录系统,你熟练使用文本相似度算法如余弦相似度,Jaccard,曼哈顿距离等,来判断原文与相似内容之间的相似度接下来,我将给你原文与相似内容.你需要给我两者的相似度结果,然后,你需要对原文进行改写,使相似度降低到-1,然后重新计算原文与相似内容的相似度最终,你会把修改后的原文给我以及他与相似内容的想似度



充当论文润色者（拿摘要部分举例）

> 请你充当一名论文编辑专家，在论文评审的角度去修改以下论文，使其更加流畅，优美。下面是具体要求：

1. 能让读者快速获得文章的要点或精髓，让文章引人入胜；能让读者了解全文中的重要信息、分析和论点；帮助读者记住论文的要点
2. 字数限制在 300 字以下
3. 请你在摘要中明确指出您的模型和方法的创新点，强调您的贡献。
4. 用简洁、明了的语言描述您的方法和结果，以便评审更容易理解论文





#### 写研究进展

参考北大核心期刊,总结《车联网中的任务卸载算法》,写一篇5000字左右的专业学术论文,要求引用文献有中文和英文,不少于20篇.

### 论文润色

润色指标：

1 删除不必要的内容
2 加强段落之间的过渡
3 修正拼写和语法错误
4 优化段落结构
5 替换过时的词汇或短语
6 增加更多的细节和具体内容
7 澄清表达意思
8 调整字母大小写规范
9 提高段落可读性
10 替换文章中的垃圾词语

通过模仿下面的的内容进行修改：

本章研究了一种车联网场景下的多MEC协作计算卸载和资源分配方案,综合考虑了车辆间干扰、卸载比例分配、MEC服务器的通信资源以及最小化时延等问题,提出了一种基于模拟退火算法的计算卸载和资源分配算法.将优化问题分解为两个子问题,一方面采用注水算法求解信道资源分配方案,采用两阶段分配使所有车辆通信速率都达到任务要求;同时,将信道分配结果作为输入,利用模拟退火算法求解卸载比例分配问题,解决了传统数学方法难以解决的NP-hard问题.通过不断降低温度,得到近似全局最优解.最后,仿真证明了本算法对比其他算法的优越性,达到了所有用户的平均时延最小化,并兼顾网络流量适中,在不同网络情况下都能发挥最优的性能.由于根据网络情况充分利用了本地和MEC的计算性能,因此能达到最优的时延.

修改的文本为：

本章研究了一种车联网环境下能耗优先的计算卸载和分配的方案。本章首先介绍了车联网中任务卸载的系统模型，包括，系统场景，车辆计算模型、车辆能耗模型，然后将问题建模为了数学规划形式，提出了一种基于基因算法的任务卸载分配算法，然后设计了相关评价标准及分析了实验结果。评价标准显示，该算法能够很好的提高资源的利用率，同时也很好的兼顾公平。但在本章的研究过程中发现了一些不足：基因算法存在着编码和解码的过程，以便于进行交叉和变异操作，这带来了计算量太大以及计算时间过长的问题。因此，下一张会引出较新的智能算法并将其修改为能解决离散问题的算法，加快算法的运行时间。



通过模仿下面的的内容， 参考北大核心期刊，总结《边缘计算》, 写一篇 1000 字左右的摘要，要求引用文献有中文和英文，不少于 20 篇.

随着智能设备的普及,单台设备的计算和存储能力已经不能满足用户的需求,人们寻找一种更方便获得计算能力的方式.云计算应运而生,在过去十年中,许多研究人员专注于研究云计算,移动用户可以通过无线访问将他们的计算密集型任务卸载到资源丰富的远程云中,用户可以方便的获取在远端服务器中的计算资源.用户不必拘泥于自身终端设备配置,直接将计算任务交给远程云,只需良好的通信环境,就可以将计算结果回传回来.现在,云计算已经大大方便了人们的生活,"远程办公"得以实现,人们不必拘泥于办公室,连上网就可以通过云服务器获得办公所需要的文件.数据可以备份到云服务器上,而不必购买笨重的移动硬盘,只需要账号和密码就可以获得比移动硬盘更快速,便捷的存储手段.移动设备和云计算结合产生了移动云计算,移动设备通过移动互联网连接到远程的云服务器,大大扩展了移动设备的计算和存储能力,也将云计算的应用场景扩展到了移动互联网.但云计算由于采用集中式计算,距离用户较远,并且需要将数据上传到核心网,增加了核心网的负担,也使数据不能做到及时响应,在自动驾驶33]等需要毫秒级响应的应用中不能发挥很好的作用.内容分发网络(content delivery network,CDN)通过将相同内容复制到多个节点,根据当前网络状况和用户距离,将用户的访问引导到距离最近的内容节点上,以提高访问效率.移动边缘计算(mobile edge computing,MEC)在此基础上做了扩展,MEC强调的是功能缓存,CDN强调的是内容缓存.MEC直接将服务部署在更靠近移动用户的接入侧,由于距离用户较近,可以实现较低时延和高带宽,并且减少核心网的负载.和之前的负载均衡不一样,MEC是就近解决用户的计算问题,不用再在全局进行流量分配.2016年5月,美国自然基金委将研究重心从云计算更改到边缘计算,并和英特尔合作讨论如何建设无线边缘网络.同年,国内也兴起了移动边缘计算的研究,2016年11月,边缘计算产业联盟在北京成立,其目的是将政治、产业、研学等各方面力量结合,推动边缘计算实际应用.











计算种群中解各个维度的方差和，种群是用 n*m 的 numpy.arrray 表示的

```python
import numpy as np

# 其中，axis=0 表示对每列（即每个维度）进行计算。在 var 函数中，可以通过 axis 参数来指定计算方差的轴，而在 sum 函数中，不指定 axis 参数则默认对所有元素求和。
# 计算每个维度上的方差
variances = np.var(population, axis=0)

# 计算所有维度上的方差和
variance_sum = np.sum(variances)

```





### 内容

| 应用关键程度 | 应用实例                                                     | 卸载   |
| ------------ | ------------------------------------------------------------ | ------ |
| CAs          | 车辆控制、碰撞预警、红绿灯警告、网上车辆诊断、道路湿滑检测等 | 不允许 |
| HPAs         | 地图导航、平视显示器、视野增强91、车辆传感等                 | 允许   |
| LPAs         | 虚拟现实、语音识别、视频处理1、在线游戏等                    | 允许   |





### 公式

$$
D=\sqrt{\sum_{i=1}^n D_i^2}\\
D_j=\frac{1}{m} \sum_{i=1}^m\left(x_{i j}-\bar{x}_j\right)^2\\
$$




$$
\begin{equation}
X_1 \overline{\mathrm{O}} X_2=
    \begin{cases}
    X_{1i}   & X_{1i}=X_{2i}\\
    0   & X_{1i}!=X_{2i}, i=1,2...n
    \end{cases}
\end{equation}
$$


任务可分

那么根据均值不等式，有 $ \sqrt [3]{\frac {\sum\limits_{i=1}^{n} a_i^3}{n}}\ge\frac {\sum\limits_{i=1}^{n} a_i}{n}$

即

$\sum\limits_{i=1}^{n}a_i^3\ge\frac{n(\sum\limits_{i=1}^{n}a_i)^3}{n^3}=\frac{C^3}{n^2}.$

因此，要使 $\sum\limits_{i=1}^{n} a_i^3$ 最小，需要让 $\sum\limits_{i=1}^{n} a_i$ 的值尽可能平均分配给 $n$ 个数，即令 $a_1=a_2=\cdots=a_n=\frac {C}{n}$。 综上，将固定值 $C$ 切割成 $n$ 个数时，要让每个数的值都等于 $\frac {C}{n}$。这样切割出来的 $n$ 个数的立方和最小，为 $\frac {C^3}{n^2}$。


$$
\sqrt [3]{\frac {\sum\limits_{i=1}^{n} a_i^3}{n}}\ge\frac {\sum\limits_{i=1}^{n} a_i}{n},
$$





% +
$\mathop {\rm{O}}\limits^ +  $

% -
$\mathop {\rm{O}}\limits^ - $

% *
$\mathop {\rm{O}}\limits^ \times  $

% dan mu
$ \odot$

### 表格

| Parameters | Values / Distribution |
| :--------: | :-------------------: |
|   $f_i$    |    $[700, 1900] $     |
|   $v_i$    |        $7.683$        |
| $\theta $  |      $-4558.52 $      |
| $\lambda$  |       $0.00125$       |
| $\Delta T$ |          $1$          |
|  $r_{it}$  |   $ U[820, 10000]$    |
| $r'_{it} $ |   $ U[200, r_{it}]$   |
|   $P_0$    |         $0.2$         |
|    $W$     |        10 MHz         |
| \text{SNR} |          677          |



### 画图

> python 画柱状图，要求：
>
> 一共有10个柱子，每个柱由两部分组成，上下两部分颜色不同，颜色分别是(92/255, 161/255, 164/255)和(212/255, 196/255, 170/255)
>
> 对于每一个柱子，上面的部分高度要高于下面部分，
>
> 画出平行于x轴， 且值为柱子的平均值的线
>
> 不显示坐标轴
>
> 将上面的柱状图保存到当前文件夹下的 “毕业论文” 子文件夹
>
> 请写出代码
>
> 



以下是数学中常用的一些重要不等式：

1. 平均值不等式 （Arithmetic Mean-Geometric Mean Inequality，AM-GM 不等式）： 对于任意非负实数 �1,�2,⋯ ,��*a*1,*a*2,⋯,*a**n* ，有 

2. $$
    \frac {a_1+a_2+\cdots+a_n}{n}\ge \sqrt [n]{a_1a_2\cdots a_n}.
    $$

3. 

4. 均值不等式 （Quadratic Mean-Arithmetic Mean Inequality，QM-AM 不等式）： 对于任意非负实数 $a_1,a_2,\cdots,a_n$ ，有

$\sqrt{\frac{a_1^2+a_2^2+\cdots+a_n^2}{n}}\ge\frac{a_1+a_2+\cdots+a_n}{n}$.

3. 加权均值不等式 （Weighted Arithmetic Mean Inequality）： 对于任意非负实数 $a_1,a_2,\cdots,a_n$ 和任意正实数 $k_1,k_2,\cdots,k_n$ ，有

$$
\frac{k_1a_1+k_2a_2+\cdots+k_na_n}{k_1+k_2+\cdots+k_n}\ge \sqrt[\large{k_1+k_2+\cdots+k_n}]{a_1^{k_1}a_2^{k_2}\cdots a_n^{k_n}}.
$$



4. 柯西 - 施瓦茨不等式 （Cauchy-Schwarz Inequality）： 对于任意实数 $a_1,a_2,\cdots,a_n$ 和 $b_1,b_2,\cdots,b_n$，有

$(a_1^2+a_2^2+\cdots+a_n^2)(b_1^2+b_2^2+\cdots+b_n^2) \ge (a_1b_1+a_2b_2+\cdots+a_nb_n)^2.$

5. 切比雪夫不等式（Chebyshev's Inequality）： 对于两组实数 $a_1\ge a_2\ge \cdots \ge a_n$ 和 $b_1\ge b_2\ge \cdots \ge b_n$ ，有

\frac{1}{n}\sum_{i=1}^{n}a_ib_i-\frac{1}{n}\left(\sum_{i=1}^{n}a_i\right)\cdot\left(\sum_{i=1}^{n}b_i\right)\le 0.

6. 布尔查诺不等式 （Bernoulli's Inequality）： 对于任意实数 $x>-1$ 和 $0\le r\le 1$，有

(1+x)^r\ge 1+rx.

7. 杨辉不等式 （Binomial Theorem Inequality）： 对于任意正整数 $n$ 和 $0\le k\le n-1$，有

(1+x)^n\ge 1+nx+\frac{n(n-1)}{2}x^2+\cdots+\binom{n}{k}x^k,

其中 $\binom {n}{k}$ 表示组合数。





#### 1小于

```python
import numpy as np
import matplotlib.pyplot as plt

# 生成数据
np.random.seed(2023)
data_top = np.random.randint(10, 20, 10)
data_bottom = np.random.randint(1, 9, 10)
x = np.arange(10)

# 创建画布和子图
fig, ax = plt.subplots(figsize=(8, 6))

# 颜色设置
c1 = (92/255, 161/255, 164/255)
c2 = (212/255, 196/255, 170/255)

# 绘制柱状图的上下两部分
ax.bar(x, data_bottom, color=c1, width=0.5, alpha=0.7, label="不可卸载任务")
ax.bar(x, data_top, bottom=data_bottom, color=c2, width=0.5, alpha=0.7, label="可卸载任务")


# 计算平均值并绘制一条平行于x轴的线
mean = np.mean(data_top) + np.mean(data_bottom)
ax.axhline(mean, color='black', linestyle='--', linewidth=2)

'''
# 隐藏坐标轴
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
ax.spines['left'].set_visible(False)
ax.spines['bottom'].set_visible(False)
'''

# 隐藏坐标轴刻度以及刻度标签
ax.set_xticks([])
ax.set_yticks([])
ax.set_xticklabels([])
ax.set_yticklabels([])
ax.legend()


import os
# 确定保存路径和文件名
folder_name = '毕业论文'
if not os.path.exists(folder_name):
    os.makedirs(folder_name)
file_name = '柱状图_小于.png'
file_path = os.path.join(folder_name, file_name)


# 保存柱状图
plt.savefig(file_path, dpi=300, bbox_inches='tight')

# 显示柱状图
plt.show()
```



#### 2大于

```python
#大于
import numpy as np
import matplotlib.pyplot as plt

# 生成数据
np.random.seed(2023)
data_top = 
[ 7  2  4  6  1 18 16 16 14  8]
data_bottom= 
[6 1 3 4 3 5 2 7 1 8]
x = np.arange(10)

# 创建画布和子图
fig, ax = plt.subplots(figsize=(8, 6))

# 颜色设置
c1 = (92/255, 161/255, 164/255)
c2 = (212/255, 196/255, 170/255)


# 绘制柱状图的上下两部分
ax.bar(x, data_top, color=c1, width=0.5, alpha=0.7, label = "不可卸载任务")
ax.bar(x, data_bottom, bottom=data_top, color=c2, width=0.5, alpha=0.7, label="可卸载任务")

# 计算平均值并绘制一条平行于x轴的线
mean = np.mean(data_top)
ax.axhline(mean, color='black', linestyle='--', linewidth=2, label="平均任务大小")

'''
# 隐藏坐标轴
ax.spines['top'].set_visible(False)
ax.spines['right'].set_visible(False)
ax.spines['left'].set_visible(False)
ax.spines['bottom'].set_visible(False)
'''

# 隐藏坐标轴刻度以及刻度标签
ax.set_xticks([])
ax.set_yticks([])
ax.set_xticklabels([])
ax.set_yticklabels([])
ax.legend()


import os
# 确定保存路径和文件名
folder_name = '毕业论文'
if not os.path.exists(folder_name):
    os.makedirs(folder_name)
file_name = '柱状图_大于.png'
file_path = os.path.join(folder_name, file_name)


# 保存柱状图
plt.savefig(file_path, dpi=300, bbox_inches='tight')

# 显示柱状图
plt.show()
```



#### 3相关性



> 使用 python画图, 实现如下功能
>
> 数据来自于两个列表, 每组列表一共n个数据, 
>
> 数据如下
>
> [71.83, 72.12,  53.58, 49.73, 64.61,  89.39, 108.19] 
>
> [69.85, 70.72,  53.49, 49.13, 61.45,  90.74, 110.0]
>
> 每两个柱状图相邻, 数据来自于两个列表中相同下标的元素 
>
> 不显示坐标轴和坐标值

```python
import matplotlib as mpl
mpl.rcParams['font.family'] = 'sans-serif'
mpl.rcParams['font.sans-serif'] = ['SimHei']


import matplotlib.pyplot as plt
import numpy as np

# 定义两个包含数据的列表
data1 = [71.83, 72.12, 53.58, 49.73, 64.61, 89.39, 108.19]
data2 = [69.85, 70.72, 53.49, 49.13, 61.45, 90.74, 110.0]

# 定义 x 轴刻度标签
labels = ['A', 'B', 'C', 'D', 'E', 'F', 'G']

# 设置图形大小
plt.figure(figsize=(8, 6))

# 获取 x 轴下标和柱状图宽度
x = np.arange(len(labels))
bar_width = 0.35


c1 = (92/255, 161/255, 164/255)
c2 = (212/255, 196/255, 170/255)




# 绘制第一组柱状图
plt.bar(x, data1, width=bar_width, color=c1, label='原始数据')

# 绘制第二组柱状图，需要将柱状图的位置向右移动一定距离以实现相邻柱状图效果
plt.bar(x+bar_width, data2, width=bar_width, color=c2, label='实验1')

# 去掉 x 轴和 y 轴
plt.axis('off')

# 添加标题
#plt.title('Bar chart with 2 data sets')

# 添加图例，并设置位置
plt.legend(loc='best')

import os
# 确定保存路径和文件名
folder_name = '毕业论文'
if not os.path.exists(folder_name):
    os.makedirs(folder_name)
file_name = '相关性1.png'
file_path = os.path.join(folder_name, file_name)


# 保存柱状图
plt.savefig(file_path, dpi=300, bbox_inches='tight')



# 显示图形
plt.show()

```

```python
import matplotlib as mpl
mpl.rcParams['font.family'] = 'sans-serif'
mpl.rcParams['font.sans-serif'] = ['SimHei']


import matplotlib.pyplot as plt
import numpy as np

# 定义两个包含数据的列表
data1 = [71.83, 72.12, 53.58, 49.73, 64.61, 89.39, 108.19]
data2 = [69.85, 70.72, 53.49, 49.13, 61.45, 90.74, 110.0]

# 定义 x 轴刻度标签
labels = ['数据集1', '数据集2', '数据集3', '数据集4', '数据集5', '数据集6', '数据集7']

# 设置图形大小
plt.figure(figsize=(8, 6))

# 获取 x 轴下标和柱状图宽度
x = np.arange(len(labels))
bar_width = 0.35


c1 = (92/255, 161/255, 164/255)
c2 = (212/255, 196/255, 170/255)


plt.xlabel('数据')
plt.ylabel('函数值')

# 绘制第一组柱状图
plt.bar(x-bar_width/2, data1, width=bar_width, color=c1, label='原始数据')

# 绘制第二组柱状图，需要将柱状图的位置向右移动一定距离以实现相邻柱状图效果
plt.bar(x + bar_width/2, data2, width=bar_width, color=c2, label='实验1')



plt.xticks(x, labels)

# 去掉 x 轴和 y 轴
# plt.axis('off')

# 添加标题
#plt.title('Bar chart with 2 data sets')

# 添加图例，并设置位置
plt.legend(loc='best')

# import os
# # 确定保存路径和文件名
# folder_name = '毕业论文'
# if not os.path.exists(folder_name):
#     os.makedirs(folder_name)
# file_name = '相关性1.png'
# file_path = os.path.join(folder_name, file_name)


# # 保存柱状图
# plt.savefig(file_path, dpi=300, bbox_inches='tight')



# 显示图形
plt.show()

```





#### 相关性2

```python

import matplotlib as mpl
mpl.rcParams['font.family'] = 'sans-serif'
mpl.rcParams['font.sans-serif'] = ['SimHei']


import matplotlib.pyplot as plt
import numpy as np

# 定义两个包含数据的列表
data1 = [77.22749999999999, 72.2325,   79.15875, 96.505, 75.3175, 65.91625, 93.44375]

data2 =[71.6163425925926, 67.98578703703704,   66.05074074074074, 93.04768518518519, 73.50074074074075, 58.6562962962963, 86.94509259259262]

#data2 = [69.85, 70.72, 53.49, 49.13, 61.45, 90.74, 110.0]

# 定义 x 轴刻度标签
labels = ['A', 'B', 'C', 'D', 'E', 'F', 'G']

# 设置图形大小
plt.figure(figsize=(8, 6))

# 获取 x 轴下标和柱状图宽度
x = np.arange(len(labels))
bar_width = 0.35


c1 = (92/255, 161/255, 164/255)
c2 = (212/255, 196/255, 170/255)




# 绘制第一组柱状图
plt.bar(x, data1, width=bar_width, color=c1, label='原始数据')

# 绘制第二组柱状图，需要将柱状图的位置向右移动一定距离以实现相邻柱状图效果
plt.bar(x+bar_width, data2, width=bar_width, color=c2, label='实验2')

# 去掉 x 轴和 y 轴
plt.axis('off')

# 添加标题
#plt.title('Bar chart with 2 data sets')

# 添加图例，并设置位置
plt.legend(loc='best')

import os
# 确定保存路径和文件名
folder_name = '毕业论文'
if not os.path.exists(folder_name):
    os.makedirs(folder_name)
file_name = '相关性2.png'
file_path = os.path.join(folder_name, file_name)


# 保存柱状图
plt.savefig(file_path, dpi=300, bbox_inches='tight')



# 显示图形
plt.show()

```





#### GA DMO 时间比较

```python
import matplotlib.pyplot as plt


maxiter = 20
xlist = [x *100 for x in range(maxiter)]

time10ga = [1.2009868621826172, 1.3047130107879639, 2.455580234527588, 3.62075138092041, 4.7826714515686035, 5.974545001983643, 7.314926385879517, 8.39737606048584, 9.464890956878662, 10.52335238456726, 11.795528650283813, 13.037211179733276, 14.182312965393066, 15.183621168136597, 16.17753529548645, 17.20527172088623, 18.230737447738647, 19.255499124526978, 20.268683671951294, 21.26105499267578]
time10dmo= [1.4902234077453613, 2.7890026569366455, 4.340714931488037, 5.895031213760376, 7.3175368309021, 8.601754665374756, 10.113687992095947, 11.401244878768921, 12.829745531082153, 14.226430416107178, 15.598066806793213, 17.165122032165527, 18.658958435058594, 19.906592845916748, 21.08903455734253, 22.359783172607422, 23.541799306869507, 24.865493774414062, 26.060691118240356, 27.437556743621826]

time15dmo= [1.5692737102508545, 3.042255163192749, 4.682401657104492, 6.160332202911377, 7.714777946472168, 9.20280146598816, 10.847264051437378, 12.322391271591187, 13.859962463378906, 15.406898498535156, 17.00578498840332, 18.476606845855713, 20.024216175079346, 21.524911165237427, 23.028636932373047, 24.651069402694702, 26.158259630203247, 27.625147342681885, 29.1461284160614, 30.746986150741577]
time15ga =  [4.083693504333496, 2.337355613708496, 4.813814640045166, 7.181896924972534, 9.900893926620483, 12.43952202796936, 15.239405155181885, 18.00296401977539, 20.42745566368103, 22.690135717391968, 24.98483633995056, 27.087273359298706, 29.734530210494995, 32.387813568115234, 35.1667366027832, 37.64374899864197, 40.06741905212402, 42.31510782241821, 44.366618156433105, 46.4537308216095]

time20dmo=  [1.7957098484039307, 3.584399938583374, 5.456485033035278, 7.331343173980713, 9.170955657958984, 11.253708124160767, 13.708238363265991, 16.009929656982422, 18.04344630241394, 20.604111909866333, 22.723008394241333, 26.10750699043274, 29.290099620819092, 31.28011131286621, 33.3964741230011, 35.56064963340759, 37.599467515945435, 39.78877282142639, 41.84518480300903, 43.91232466697693]
time20ga = [2.5796828269958496, 2.5994317531585693, 5.15914511680603, 7.6699841022491455, 10.349720239639282, 13.092692613601685, 15.87472939491272, 18.65923261642456, 21.68128252029419, 24.724026679992676, 27.457414865493774, 29.9023277759552, 
32.378493785858154, 34.89628982543945, 37.36975860595703, 39.8710834980011, 42.39708352088928, 45.1208291053772, 47.910075426101685, 50.44931674003601]



time25dmo =[2.349295139312744, 4.840264797210693, 7.158748388290405, 9.388331890106201, 11.756947040557861, 14.189761400222778, 17.463051795959473, 19.796664237976074, 22.490368604660034, 25.821796417236328, 28.45606565475464, 31.07062816619873, 33.43058109283447, 35.85056400299072, 38.24378776550293, 40.84212136268616, 42.93924021720886, 46.634467124938965, 48.911346673965454, 51.11555624008179]
time25ga=[3.8054721355438232, 3.6794915199279785, 7.533619165420532, 11.0933256149292, 15.00750732421875, 18.61030626296997, 22.263903379440308, 25.683808088302612, 29.023042678833008, 32.52644371986389, 36.196736335754395, 39.8105034828186, 43.468557357788086, 47.021790504455566, 50.57403874397278, 54.34753966331482, 57.9428334236145, 61.55703830718994, 65.09417271614075, 68.67860388755798]

time30ga =  [5.019534349441528, 4.9426329135894775, 9.726829528808594, 14.71841025352478, 19.583006620407104, 25.001736640930176, 30.084389686584473, 34.984960079193115, 39.98980712890625, 45.057782888412476, 50.52648401260376, 55.75725436210632, 60.50243639945984, 65.30553579330444, 70.093905210495, 75.05111980438232, 80.63063478469849, 85.76639819145203, 90.68378114700317, 96.2155339717865]
time30dmo=  [2.342075824737549, 4.7005295753479, 7.039023399353027, 9.392715454101562, 11.787015438079834, 14.238481521606445, 16.714126110076904, 19.03627896308899, 21.37484312057495, 23.728891134262085, 26.12498116493225, 28.477160930633545, 30.809778690338135, 33.20827555656433, 35.591728925704956, 37.935380935668945, 40.27775955200195, 42.67417573928833, 45.00213265419006, 47.37625312805176]
time40ga =  [17.4332377910614, 14.696282625198364, 28.98535919189453, 50.74865221977234, 71.26493430137634, 87.42369866371155, 105.43781185150146, 120.90864872932434, 136.3720247745514, 152.31878900527954, 168.30886602401733, 183.22503805160522, 198.47199058532715, 214.01840901374817, 229.0337541103363, 245.7441725730896, 265.2726254463196, 287.4796152114868, 
306.77690839767456, 321.79243874549866]
time40dmo=  [2.795224666595459, 5.708191394805908, 8.622104406356812, 11.552967548370361, 14.477360963821411, 17.393771409988403, 20.338930130004883, 23.273017644882202, 26.20781445503235, 29.13410210609436, 32.057878732681274, 34.968061685562134, 37.90592122077942, 40.82455658912659, 43.737295150756836, 46.68498206138611, 49.61474657058716, 52.5520122051239, 55.49935054779053, 58.46456265449524]

time35ga = [11.197139024734497, 10.822482109069824, 21.402564764022827, 32.74186849594116, 43.20140242576599, 53.61943554878235, 64.3576807975769, 74.87854766845703, 85.30001926422119, 96.08481860160828, 107.08807849884033, 117.57921147346497, 128.1483073234558, 138.65358996391296, 148.87270855903625, 159.69996285438538, 170.55504536628723, 181.80730652809143, 192.3898525238037, 203.43824315071106]
time35dmo= [2.600299119949341, 5.262592315673828, 7.925434589385986, 10.586715698242188, 13.286141157150269, 15.99670147895813, 18.627877235412598, 21.29526448249817, 23.949804544448853, 26.58668279647827, 29.2897527217865, 31.9253351688385, 34.568440675735474, 37.19776511192322, 39.83616638183594, 42.49098205566406, 45.15943694114685, 47.80777955055237, 50.438523054122925, 53.077136754989624]

c = 'black'
plt.plot(xlist, time15ga, color = 'green', label = '15GA', linestyle='--')
plt.plot(xlist, time15dmo, color = 'green', label = '15DMO')


plt.plot(xlist, time20ga, color = "blue", label = '20GA', linestyle='--')
plt.plot(xlist, time20dmo, color = "blue", label = '20DMO')
plt.plot(xlist, time25ga, color = 'm', label = '25GA', linestyle='--')
plt.plot(xlist, time25dmo, color = 'm', label = '25DMO')


plt.plot(xlist, time10ga, color = 'r', label = '10GA', linestyle='--')
plt.plot(xlist, time10dmo, color = 'r', label = '10DMO')


plt.xlabel('Iteration')
plt.ylabel('Time')

plt.yticks(visible= True) 

plt.yticks(visible= True) 
plt.legend()
plt.show()
```





#### DMO _d

```python
```





#### 获得算法时间

```python
    # 记得取消 DDMO.py ->run的注释
    numlist = [10, 15, 20, 25, 30, 35, 40]
    # 获取运行的时间
    for i in numlist:
        gettime(i)
```









#### 能耗 ga

```python
import matplotlib as mpl
mpl.rcParams['font.family'] = 'sans-serif'
mpl.rcParams['font.sans-serif'] = ['SimHei']





e10 = [27.98898148148148, 22.033472222222223, 32.859722222222224, 32.51722222222222, 40.202222222222225, 40.202222222222225, 36.748472222222226, 36.748472222222226, 36.748472222222226, 36.748472222222226, 36.748472222222226, 36.748472222222226, 36.748472222222226, 36.748472222222226, 36.748472222222226, 36.748472222222226, 36.748472222222226, 36.748472222222226, 36.748472222222226, 36.748472222222226]

e15 = [75.40907407407407, 54.29467592592593, 47.095277777777774, 54.811342592592595, 53.61009259259259, 52.7288425925926, 52.7288425925926, 52.432546296296294, 50.510046296296295, 49.7212962962963, 49.7212962962963, 49.7212962962963, 49.7212962962963, 49.7212962962963, 49.7212962962963, 49.7212962962963, 49.7212962962963, 48.4375462962963, 48.4375462962963, 48.4375462962963]
'62.044999999999995'


e20 =  [144.71925925925925, 87.6588888888889, 64.30166666666666, 49.124583333333334, 37.26888888888889, 37.586296296296304, 37.29319444444445, 43.78694444444445, 44.61152777777779, 43.00625, 51.45250000000001, 50.870000000000005, 67.51624999999999, 70.83810185185185, 58.21870370370371, 56.092453703703704, 58.6937037037037, 57.446203703703695, 55.6112037037037, 55.6112037037037]

e25 = [245.46365740740737, 193.45592592592592, 154.5021759259259, 121.76564814814813, 93.79555555555555, 78.42837962962963, 59.6249537037037, 51.66115740740741, 54.739074074074075, 55.97208333333333, 57.779722222222226, 54.51203703703704, 52.564537037037034, 51.939537037037034, 51.346944444444446, 51.26203703703704, 51.26203703703704, 51.26203703703704, 51.26203703703704, 51.26203703703704]
'83.3675'

plt.axhline(47.27375000000001, color = 'green', linestyle='dashed')
plt.axhline(62.044999999999995, color = 'y', linestyle='dashed')

plt.axhline(71.05624999999999, color = "blue", linestyle='dashed')
plt.axhline(83.3675, color = "m", linestyle='dashed')

maxiter = 20
xlist = [x *100 for x in range(maxiter)]

plt.plot(xlist, e10, color = 'green', label = '10')
plt.plot(xlist, e15, color = 'yellow', label = '15')
plt.plot(xlist, e20, color = "blue", label = '20')
plt.plot(xlist, e25, color = 'm', label = '25')


plt.ylabel("能耗")
plt.xlabel("迭代次数")

plt.legend()
plt.show()

```



```python
import matplotlib as mpl
mpl.rcParams['font.family'] = 'sans-serif'
mpl.rcParams['font.sans-serif'] = ['SimHei']


e30 =  [270.19143519, 218.35842593, 187.14615741, 147.89490741, 116.99222222, 103.99912037, 92.4437963, 81.43421296, 80.26509259, 71.60097222, 71.91875, 65.84467593, 58.87064815, 63.26236111, 63.16962963, 56.84888889, 55.07111111, 53.21166667, 57.14842593, 58.23759259]

e35 =  [390.08550925925925, 337.80814814814806, 291.27972222222223, 252.7140740740741, 228.03541666666666, 199.54240740740744, 175.9799537037037, 161.3262037037037, 141.52245370370372, 133.89050925925923, 117.09527777777777, 112.71847222222222, 116.0736111111111, 122.02921296296294, 122.02921296296294, 122.02921296296294, 122.02921296296294, 119.7437037037037, 128.09180555555554, 123.4622685185185]


e40 = [499.68796296296296, 433.39898148148154, 379.9224537037037, 324.65143518518516, 286.82916666666665, 251.70305555555558, 233.70907407407407, 222.75217592592594, 213.73708333333332, 198.13907407407407, 194.06268518518516, 175.09925925925927, 172.10560185185187, 169.06935185185185, 160.6362037037037, 159.55875, 162.28694444444443, 156.83856481481482, 156.83856481481482, 156.83856481481482]


plt.plot(xlist, e30, color = 'black', label = '30')
plt.plot(xlist, e35, color = 'r', label = '35')
plt.plot(xlist, e40, color = 'c', label = '40')


plt.axhline(131.08, color = 'black', linestyle='dashed')
plt.axhline(161.40499999999997, color = "r", linestyle='dashed')

plt.axhline(172.05125, color = 'c', linestyle='dashed')


plt.ylabel("能耗")
plt.xlabel("迭代次数")

plt.legend()
plt.show()
```





#### getd()

```python
    def getd(self):
        # 其中，axis=0 表示对每列（即每个维度）进行计算。在 var 函数中，可以通过 axis 参数来指定计算方差的轴，而在 sum 函数中，不指定 axis 参数则默认对所有元素求和。
        # 计算每个维度上的方差
        variances = np.var(self.X, axis=0)

        # 计算所有维度上的方差和
        sum= np.sum(variances)
        return np.sqrt(sum)

```



#### 概率变化图

```python

import numpy as np
import matplotlib.pyplot as plt

import matplotlib as mpl
mpl.rcParams['font.family'] = 'sans-serif'
mpl.rcParams['font.sans-serif'] = ['SimHei']

x = np.linspace(0 ,50, 100)
# y = 1 / (np.exp(-x) + 1)

y = 1 / (np.exp(x * 0.1) )

plt.plot(x, y, color='black')
plt.xlabel(r'$\varphi$')
plt.ylabel('p')
# plt.title('概率值变化')
plt.grid(True)
plt.show()

```







#### 侏儒猫鼬算法函数图 CF  

```python
import numpy as np
import matplotlib.pyplot as plt

# 定义函数
def func(x):
    return (1 - x) ** (2 * x)

# 生成 x 值数组
x = np.linspace(0, 1, 100)

# 计算对应的 y 值数组
y = func(x)

# 绘制图形
plt.plot(x, y)
plt.xlabel('x')
plt.ylabel('CF')
plt.title('Plot of CF=(1-x)^(2x)')
plt.grid(True)
plt.show()

```











### 背景_车辆云



### 算法

#### 遗传算法

请模拟下文来写出基因算法的流程，下文是：

(I)输入初始化参数.设置计算迭代次数itermax、迭代初始温度和终止温度.初始温度T.一般设置较高的值,可以为1000.随着迭代次数增加当前温度呈递减趋势.随机生成初始解xo,同时给定目标函数f(x).

(2)外部迭代次数依次增加,在实际退火场景中,温度更新规则为:其中,α为退火率,取值越接近1表示退火速率越慢,取值越小越能快速降温到终止温度.在内部迭代循环结束后根据公式(3-12)生成下一温度,同时开始内循环,直至达到终止温度.

(3)进入内循环,假设内循环当前迭代次数为s,在s+1步时,对当前解进行随机扰动,生成新解,对新解进行目标函数计算,假设当前解的目标函数值为E(S),新解的目标函数值为E(s+1),如果新解小于当前解,则接受此新解,如果新解大于当前解,则以概率ep66接受此新解为当前解.其中c为Boitzann常数,同时维护一个历史最优解变量,每次迭代更新此历史最优解.

(4)在温度Tk下达到最大迭代次数时,即在当前温度稳定.重复进行步骤(2),k=k+1,进入下一个温度.

(5)判断Tk是否达到终止温度,如果达到,算法终止,历史最优解变量即为全局最优解,否则继续进入步骤(2).



#### LPT

LPT 算法是一种常用的任务调度算法，全称为 Longest Processing Time，中文翻译为 “处理时间最长法”。LPT 算法是一个贪心算法，可以用于解决单处理机和多处理机任务调度问题。通常情况下，LPT 算法用于单处理机时表现较好。

在使用 LPT 算法进行任务调度时，会首先将所有待处理的任务按照所需处理时间从大到小排序。接下来，从前往后依次将任务分配给可用的处理器，使得处理时间最长的任务尽量早地被处理，处理时间较短的任务则留到后面执行。具体来说，LPT 算法的执行步骤如下：

1. 将所有待处理的任务按照所需处理时间从大到小排序。
2. 依次将任务分配给可用的处理器，使得处理时间最长的任务尽量早地被处理。
3. 如果当前处理器都已经被占用，则等待当前最快被释放的处理器解锁后再进行调度。
4. 直到所有任务都被分配并完成。

LPT 算法具有简单易实现、效率较高等优点，但存在可能出现负载不均衡的缺点。因此，在实际应用中需要根据具体情况灵活选择任务调度算法。







#### SPT

SPT 算法是一种常用的任务调度算法，全称为 Shortest Processing Time，中文翻译为 “处理时间最短法”。SPT 算法是一个贪心算法，可以用于解决单处理机和多处理机任务调度问题。通常情况下，SPT 算法用于优先考虑短任务或需要提高作业响应时间的场景。

在使用 SPT 算法进行任务调度时，会首先将所有待处理的任务按照所需处理时间从小到大排序。接下来，从前往后依次将任务分配给可用的处理器，使得处理时间最短的任务尽量早地被处理，处理时间较长的任务则留到后面执行。具体来说，SPT 算法的执行步骤如下：

1. 将所有待处理的任务按照所需处理时间从小到大排序。
2. 依次将任务分配给可用的处理器，使得处理时间最短的任务尽量早地被处理。
3. 如果当前处理器都已经被占用，则等待当前最快被释放的处理器解锁后再进行调度。
4. 直到所有任务都被分配并完成。

SPT 算法具有简单易实现、能够提高作业响应时间等优点，但存在可能出现负载不均衡的缺点。因此，在实际应用中需要根据具体情况灵活选择任务调度算法。









